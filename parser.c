/*
BATCH 46
MANAN KHASGIWALE (2013A7PS128P)
ABHINAV AGARWAL (2013A7PS124P)
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "parserDef.h"
#include "lexer.h"

int nonterms = 0, terms = 0;
int grammar[100][20];
//int n=0;

void init() {
	int p,o;
	for(p=0;p<100;p++)
		for(o=0;o<20;o++)
			grammar[p][o]=-1;
	char* token=NULL, *x=NULL;
	char s[3] = "\n\r";
	FILE *fp = fopen("nonterm.txt","r");
	char str[50];
	while(!feof(fp)) {
		fgets(str,50,fp);
		token = strtok_r(str, s, &x);
		nonterm[nonterms].id = nonterms;
		strcpy(nonterm[nonterms++].name, token);
	}
	fclose(fp);
	FILE *fp1 = fopen("term.txt","r");
	while(!feof(fp1)) {
		fgets(str,50,fp1);
		token = strtok_r(str, s, &x);
		term[terms].id = 100+terms;
		strcpy(term[terms++].name, token);
	}
	fclose(fp1);
}

int search(char* str, int flag1) {
	int i, len;
	if(flag1) len = nonterms;
	else len = terms;
	for(i = 0; i < len; i++) {
		if(flag1 && !strcmp(nonterm[i].name, str)) return i;
		else if (!flag1 && !strcmp(term[i].name, str)) return i;
	}
	return 0;
}

void convertGrammar() {
	FILE *fp = fopen("grammar.txt","r");
	char* B = (char*)malloc(1000*sizeof(char));
	const char s[4] = " \n\r";
	int num, flag1, i, rule=0;
	char *token=NULL, *x=NULL;
	init();
	while(!feof(fp)) {
		fgets(B, 1000, fp);
		i = 0;
		token = strtok_r(B, s,&x);
		while(token != NULL) {
			if(token[0] == '<') {
				flag1 = 1;
				num = search(token, flag1);
				grammar[rule][i++] = nonterm[num].id;
			} else if(token[0] == 'T') {
				flag1 = 0;
				num = search(token, flag1);
				grammar[rule][i++] = term[num].id; 
			} else if(token[0] == 'e') { //epsilon
				grammar[rule][i++] = 666;
			} else if(token[0]=='|') {
				rule++;
				i=1;
				grammar[rule][0] = grammar[rule-1][0];
			}
			token = strtok_r(NULL, s, &x);
		}
		rule++;
	}
	/*int q,w;
	for(q=0;grammar[q][0]!=-1;q++) {
		for(w=0;grammar[q][w]!=-1;w++) {
			printf("%d ", grammar[q][w]);
		}
		printf("\n");
	}*/
	
	fclose(fp);
}

//this is the parse table for the grammar
int T[50][53] = {
{1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{4,-1,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,8,-1,-1,-1,-1,-1,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,9,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,10,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1,-1,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,17,-1,-1,17,-1,-1,17,-1,-1,-1,17,-1,-1,-1,-1,-1,17,-1,-1,17,-1,-1,-1,17,-1,-1,-1,17,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,17,-1},
{-1,-1,-1,-1,-1,-1,-1,19,-1,-1,19,-1,-1,18,-1,-1,-1,19,-1,-1,-1,-1,-1,19,-1,-1,19,-1,-1,-1,19,-1,-1,-1,19,19,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,19,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,21,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,22,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,24,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,26,-1,-1,26,-1,-1,-1,-1,-1,-1,25,-1,-1,-1,-1,-1,26,-1,-1,26,-1,-1,-1,26,-1,-1,-1,26,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,27,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,29,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,30,-1,-1,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,30,-1,-1,30,-1,-1,31,30,-1,31,31,30,30,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,31,-1},
{-1,-1,-1,-1,-1,-1,-1,36,-1,-1,32,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,36,-1,-1,33,-1,-1,-1,34,-1,-1,-1,35,35,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,37,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,38,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,39,40,-1,-1,-1,-1,-1,39,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,41,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,41,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,42,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,43,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,44,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,45,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,46,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,47,48,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,49,50,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,53,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,51,52,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,54,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,54,-1,-1,-1,-1,-1,-1,-1,-1,54,54,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,56,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,56,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,55,55,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,57,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,57,-1,-1,-1,-1,-1,-1,-1,-1,57,57,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,59,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,59,-1,-1,-1,-1,-1,-1,-1,-1,-1,58,58,59,59,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,61,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,60,-1,-1,-1,-1,-1,-1,-1,-1,61,61,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,64,65,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,66,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,67,-1,-1,-1,-1,-1,66,-1,-1,-1,-1,-1,-1,-1,-1,-1,66,66,66,66,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,69,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,68,-1,-1,-1,-1,-1,-1,-1,-1,69,69,-1,-1,-1,-1,70,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,71,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,72,73,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,74,75,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,76,77,78,79,80,81,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,82,-1},
{-1,-1,-1,84,-1,-1,-1,83,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,85,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,87,-1,-1,-1,-1,-1,-1,86,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}};
//endofT

///parsing********************************************************************
stack s;

int push(int i) {  //return 0 if successful else return -1
	if(s.top == MAX-1) {
		//printf("stack is full\n");
		return -1;
	} else {
		s.top++;
		s.symbols[s.top] = i;
		return 0;
	}	
}

int pop() { //return popped element if successful else return -1
	int temp;
	if(s.top == -1) {
		//printf("stack is empty\n");
		return -1;
	} else {
		temp = s.symbols[s.top];
		//printf("%d popped\n", temp);
		s.top--;
		return temp;
	}
}

int isEmpty() {//if empty return 0 if not return -1
	if(s.top == -1)
		return 0;
	else return -1;
}

void display() {
	int i;
	if(s.top== -1) {
		printf("stack is empty\n");
		return;
	}else {
		printf("\nstack follows: \n");
		for(i = s.top; i >= 0; i--){
			printf("%d\n", s.symbols[i]);
		}
	}
	printf("\n");
}

parseTree *parseInputSourceCode(FILE *fp, FILE *ferr) {
	buffer B = malloc(1000*sizeof(char));
	tokenInfo token1;
	int col,j, line=0, rule;
	convertGrammar();
	int temp1 = 1;
	int temp2 = 0;
	int *pos = &temp2;
	int *flag = &temp1;
	s.top = -1;
	push(900);
	push(0);
	parseTree *p, *curr, *prev, *temp;
	p = (parseTree *)malloc(sizeof(parseTree));
	strcpy(p->lexeme,"ROOT");
	strcpy(p->token,"<program>");
	p->line = 1;
	p->isLeafNode = 0;
	p->child = NULL;
	p->right = NULL;
	p->left = NULL;
	p->parent = NULL;
	strcpy(p->nodeSymbol,p->token);
	//parse through the file
	prev = p;
	while( !feof(fp) ) {
		if(*flag){ // get next line when end of line
			fp = getStream(fp,B,1000);
			line = line + 1;
			*flag = 0;
		}
		token1 = getNextToken(B, ferr, line, flag, pos); //get token		
		//do not parse errornous and empty tokens
		if(!strcmp(token1.token,"TK_COMMENT")) continue;
		if(!strcmp(token1.token,"EMPTY")) continue;
		if(!strcmp(token1.token,"error")) continue;
		if(token1.line<0) continue;
		
		while(1) {
			col = search(token1.token,0);
			//printf("line = %d  column = %d   %s\n",line, col, token1.token);

			//if top of stack non terminal
			if(s.symbols[s.top] < 100) {
				
				rule = T[s.symbols[s.top]][col];
				if(rule == -1) {
					break;
				}
				curr = (parseTree *)malloc(sizeof(parseTree));	
				//prev->child = curr;
				if(grammar[rule-1][1] < 100 ) {
					strcpy(curr->lexeme, "----");
					strcpy(curr->token,nonterm[grammar[rule-1][1]].name);
					curr->isLeafNode = 0;	
					strcpy(curr->nodeSymbol,"------");
				}
				else if (grammar[rule-1][1] == 666) {
					strcpy(curr->lexeme, "EPSILON");
					strcpy(curr->token, "EPSILON");
					curr->isLeafNode = 1;
					strcpy(curr->nodeSymbol,curr->token);
				} 
				//(grammar[rule-1][1] >=100 && grammar[rule-1][1] != 666) {
				else{
					strcpy(curr->lexeme, "----");
					strcpy(curr->token,term[grammar[rule-1][1]-100].name);
					curr->isLeafNode = 1;
					strcpy(curr->nodeSymbol,curr->token);
				}
				curr->value.i = -1;
				curr->child = NULL;
				curr->right = NULL;
				curr->left = NULL;
				curr->parent = prev;
				strcpy(curr->nodeSymbol,curr->token);
				
				
				prev->child = curr;
				for(j = 2; grammar[rule-1][j] != -1; j++){
					temp = (parseTree *)malloc(sizeof(parseTree));
					curr->right = temp;
					if(grammar[rule-1][j] < 100 ) {
						strcpy(temp->lexeme, "----");
						strcpy(temp->token,nonterm[grammar[rule-1][j]].name);
						temp->isLeafNode = 0;	
					}
					if(grammar[rule-1][j] >= 100) {
						strcpy(temp->lexeme, "----");
						strcpy(temp->token,term[grammar[rule-1][j]-100].name);
						temp->isLeafNode = 1;
					}
					temp->value.i = -1;
					temp->child = NULL;
					temp->right = NULL;
					temp->left = curr;
					temp->parent = curr->parent;
					strcpy(temp->nodeSymbol,temp->token);
					curr = curr->right;
				}
				j--;
				pop();
				while(j>0) push(grammar[rule-1][j--]);
				while(curr->left!=NULL) curr = curr->left;
				prev = curr;
			}
			//if top of stack is epsilon
			if(s.symbols[s.top] == 666) {
				if(prev->right == NULL){
					while(prev->right == NULL){
						prev = prev->parent;
					}	
				}
				prev = prev->right;
				pop();
				continue;
			}
			//if top of stack terminal and lookahead match
			if(s.symbols[s.top] == col+100) {
				strcpy(prev->lexeme, token1.lexeme);
				prev->line = token1.line;
				if(prev->right == NULL){
					while(prev->right == NULL){
						prev = prev->parent;
						if(prev==NULL) break;				
					}	
				}
				pop();
				if(prev==NULL)break;
				prev = prev->right;
				break;
			}
			//if top of stack terminal and lookahead match dont match
			if(s.symbols[s.top] != col+100 && s.symbols[s.top] >= 100) {
				fprintf(ferr, "ERROR_5: The token <%s> for lexeme<%s> does not match at line <%d>. The expected token here is <%s>\n",term[col].name,token1.lexeme,token1.line,term[s.symbols[s.top]-100].name);
				pop();
				continue;
			}
			
		}
	}
	//display();
	if(s.symbols[s.top]==900) printf("Successful Compilation\n");
	else {
		printf("Errors Found\n");
		printf("Check errors.txt for detailed info.\n");
	}
	return p;
}

void printParseTree(parseTree *p, FILE *out) {
	if(p==NULL) return;
	
	if(strcmp(p->token,"TK_RNUM")==0) p->value.f = atof(p->lexeme);
	if(strcmp(p->token,"TK_NUM")==0) p->value.i = atoi(p->lexeme);
	char parentNodeSym[30];
	if(p->parent==NULL) strcpy(parentNodeSym,"------");
	else strcpy(parentNodeSym, p->parent->nodeSymbol);
	if(strcmp(p->token,"TK_RNUM")!=0) 
		fprintf(out, "%20s %3d %20s %9d %20s %d %20s\n",p->lexeme, p->line, p->token, p->value.i, parentNodeSym, p->isLeafNode, p->nodeSymbol);
	else
		fprintf(out, "%20s %3d %20s %9.2f %20s %d %20s\n",p->lexeme, p->line, p->token, p->value.f, parentNodeSym, p->isLeafNode, p->nodeSymbol);

	printParseTree(p->child,out);
	
	printParseTree(p->right,out);
	
}
